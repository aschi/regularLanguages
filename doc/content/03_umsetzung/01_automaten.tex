\subsection{Automaten}
Es wurde versucht Automaten sowohl möglichst nah an der theoretischen Vorgabe als auch möglichst effizient zu implementieren. Herausgekommen ist dabei folgende Grundimplementation:
\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\textwidth]{images/dfa_classdiag_simple.pdf}
  \caption[DFA Klassendiagramm vereinfacht]{DFA Klassendiagramm vereinfacht}
  \label{fig:dfa_classdiag_simple}
\end{figure}

Das Quintupel ($Q$, $\Sigma$, $\delta$, $q0$, $F$) ist darin wie folgt abgebildet:

\begin{table}[h]
  \centering
  \begin{tabular}{ l | l }
    \hline
    $Q$ & Die Menge der Zustände wurde als Set von States implementiert.  \\
    \hline
    $\Sigma$ & Das Alphabet ist ein Array von Zeichen (Character). \\
    \hline
    $\delta$ & Die Übergangsfunktion $\delta$ wird als Map (Zeichen -> Zustand) 
    \\ & auf den einzelnen Zuständen abgebildet. Dies erlaubt uns eine
    \\ & einfache und effiziente Verarbeitung von Eingaben sowohl auf
    \\ & Zustands als auch auf Automaten Ebene. \\
    \hline
    $q0$ & Eine Referenz zum Startzustand $q0$ ist in der DFA Klasse hinterlegt. \\
    \hline
    $F$ & Die Menge der Akzeptierenden Zustände wird durch ein Set auf dem \\ & jeweiligen DFA Objekt representiert. \\
    \hline 
  \end{tabular}
  \caption[Implementation Automaten]{Implementation automaten}
\end{table}

Ein solcher Automat kann nun mithilfe seiner $process(Word)$ Funktion ein Wort (Eine Liste von Zeichen) verarbeiten indem er sich die Referenz des ersten Zustandes $startState$ holt und dann Zeichen für Zeichen jeweils mit $process(Character)$ die Referenz des nächsten Zustandes herausliest. Zurückgegeben wird schlussendlich derjenige Zustand der am Ende der verarbeiteten Zeichenkette erreicht wurde. Mithilfe der $isAcceptingState(State)$ Methode könnte man nun feststellen ob das Wort akzeptiert wird oder nicht. 

Zum besseren Verständnis folgend die Process Methode der DFA Klasse als Pseudocode:

\begin{lstlisting}[language=Python, caption={Process Methode der DFA Klasse}]
def process(word):
  state = startState
  for char in word:
    state = state.process(char)
  return state
\end{lstlisting}

\paragraph{Visualisierung}
Zur Visualisierung der Automaten wurde Graphviz \cite{graphviz} mit dem Graphviz Java API \cite{graphvizjava} verwendet. Konkret wurde ein Interface \lstinline$GraphvizRenderable$ entwickelt welches Klassen vorschreibt die \lstinline$generateDotString()$ Methode zu implementieren.

In der statischen Klasse \lstinline$GraphvizRenderer$ wurde eine Methode \lstinline$renderGraph(GraphvizRenderable, FileName)$ implementiert welche das API ansteuert und das gegebene \lstinline$GraphvizRenderable$ Objekt als SVG Vektorgraphik abspeichert.

Damit das generieren der Grafiken funktioniert, muss die \lstinline$generateDotString()$ Methode eine gültige Graphviz DOT Graphbeschreibung als String zurückgeben. Automaten sind eine Form von Digraphen und können in der DOT Sprache wie folgt beschrieben werden:

\begin{lstlisting}[language=Java, caption={Automat in DOT Sprache}, label={lst:dot_language}]
digraph G {
  q0 -> q1 [label="0"]
  q0 -> q2 [label="1"]
  q1 -> q2 [label="0"]
  q1 -> q0 [label="1"]
  q2 -> q0 [label="0"]
  q2 -> q1 [label="1"]
  q2 [peripheries=2]
  q0 [color=darkred]
}
\end{lstlisting}

\begin{itemize}
  \item \lstinline$digraph G$ definiert den Graphentypen
  \item \lstinline$q0 -> q1$ definiert den vom Knoten \lstinline$q0$ auf den Knoten \lstinline$q1$
  \item \lstinline$[label="0"]$ fügt die Beschriftung \lstinline$0$ dem Übergang hinzu
  \item \lstinline$[peripheries=2]$ umrandet den entsprechenden Knoten doppelt
  \item \lstinline$[color=darkred]$ färbt den entsprechenden Knoten dunkelrot ein
\end{itemize}

Eine Anleitung zur DOT Sprache ist in den Quellen verlinkt. \cite{graphvizdotref}


\paragraph{Vereinfachung}
Um die konsistent der Automaten zu erhöhen und um eine Aufsplittung zu verhindern, wurde eine Methode zum entfernen aller nicht erreichbarer Zustände implementiert. Was mit Aufsplittung gemeint ist lässt sich am einfachsten am folgenden Beispiel erklären:

\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\textwidth]{images/split_automaton.pdf}
  \caption[Aufgesplitteter Automat]{Aufgesplitteter Automat}
  \label{fig:split_dfa}
\end{figure}

In der Abbilundg \ref{fig:split_dfa} sehen wir einen Automaten mit 5 Zuständen bei welchem es keine Verbindung zwischen dem Block $q0$, $q1$, $q2$ und $q3$, $q4$ gibt. Damit ist es auch nicht möglich vom Startzustand aus ($q0$) den einzigen akzeptierenden Zustand ($q4$) zu erreichen.

In der Methode zum entfernen der nicht erreichbaren Zustände werden vom Startzustand aus alle möglichen Verbindungen getestet. Jene Zustände die so nicht erreicht werden können werden nicht beibehalten. Zum besseren Verständnis ist folgend die Methode als in Python-Pseudocode dokumentiert.  

\begin{lstlisting}[language=Python, caption={Algorithmus zum entfernen von nicht erreichbaren Zuständen}, label={lst:remove_unreachable_states}]
def removeUnreachableStates(dfa):
  processed = []
  current = dfa.getStartState()
  queue = [current]
  
  while queue.size > 0:
    nextList = []
    for char in dfa.getAlphabet():
      nextList.append(current.process(char))

    processed.append(current)
    queue.remove(current)

    for nextState in nextList:
      if !processed.contains(nextState):
        queue.append(nextState)

    current = queue[0]

  newStates = processed
  dfa.setStates(newStates)
\end{lstlisting}

\subsubsection{RandomDeterministicFiniteAutomaton}
Der \lstinline$RandomDeterministicFiniteAutomaton$ ist ein erweiterter DFA welcher den normalen endlichen Automaten um einen zufälligen Konstruktor und eine \lstinline$mutate$ Methode zum zufälligen mutieren des Automaten erweitert.

\paragraph{Der Konstruktor} erzeugt mithilfe eines gegebenen Alphabets und einem Faktor für die Komplexität des Problems - wie folgt beschrieben - zufällige Automaten.
\begin{enumerate}
  \item Es wird eine Menge von Zuständen erzeugt (Anzahl Zustände: $1$ - $(2 \cdot AnzahlZeichen \cdot Komplexitaet)$ wobei $AnzahlZeichen$ die Anzahl der Zeichen des Alphabets und die $Komplexität$ ein Faktor ist welcher als Parameter an den Konstruktor übergeben wird).
  \item Jedem Zustand werden für jedes Zeichen des Alphabets zufällig Verbindungen auf andere Zuständen zugeordnet.
  \item Der erste Zustand (q0) wird zum Startzustand.
  \item Um sicherzustellen dass jeder Automat erreichbare akzeptierende Zustände hat, werden alle nicht erreichbaren Zustände entfernt.
  \item Eine zufällige Menge von Zuständen ($1$ - $\frac{AnzahlZustaende}{5}$) wird zu akzeptierenden Zuständen.
\end{enumerate}


\paragraph{Die \lstinline$mutate$ Methode} greift auf ein Mutationsregister zurück in welchem die Methoden zum Verändern von Automaten registriert sind. Dabei wählt es zufällig eine Methode aus und führt diese durch. Wenn die Mutation erfoglreich war sind wir fertig. Wenn nicht wird erneut eine Zufällige Methode ausgesucht. Dies wird solange wiederholt bis der Automat erfolgreich verändert wurde.

\begin{center}
  \begin{tabular}{| l | p{7cm} | p{4cm} |}
    \hline
    \textbf{Aktion} &  \textbf{Beschreibung} & \textbf{Bedingungen}\\
    \hline
    Zustand hinzufügen 
    & Es wird ein Zustand zum automaten hinzugefügt. Für jedes Zeichen im Alphabet wird ein Übergang auf einen zufälligen Zustand des Automaten gelegt. Danach wird berechnet wieviele Verbindungen in diesem Automaten durchschnittlich zu einem Zustand führen ($avg$). Mit diesem Resultat werden zwischen $\frac{avg}{2}$ und $avg \cdot 2$ zufällig ausgewählte Verbindungen von zufällig ausgewählten Zuständen zum neuen gelegt.
    & - \\
    \hline
    Zustand entfernen
    & Es wird zufällig ein Zustand ausgewählt und entfernt. Alle Übergänge die auf diesen Zustand zeigen werden zufällig auf andere Zustände umgeleitet.
    & Nicht der letzte Zustand; Nicht der letzte akz. Zustand \\
    \hline
    Akz. Zustand hinzufügen
    & Es wird ein zufälliger nicht akzeptierender Zustand ausgewählt. Dieser wird zum akzeptierenden Zustand gemacht.
    & Nicht akzeptierende Zustände vorhanden \\
    \hline
    Akz. Zustand entfernen
    & Es wird ein zufälliger akzeptierender Zustand ausgewählt. Dieser wird zu einem regulären nicht-akzeptierenden Zustand umgewandelt.
    & Nicht der letzte akz. Zustand \\
    \hline
    Übergang ändern
    & Es wird ein zufälliger Zustand und ein zufälliges Zeichen ausgewählt. Der abgehende Übergang für das gewählte Zeichen wird zufällig auf einen anderen Zustand gelegt.
    & - \\
    \hline 
  \end{tabular}
  \captionof{table}{Mutationen}
\end{center}

